Development Plan:
 - Create Vector, Tensor Classes
     - Write definitions + test all methods... see that they're working

 - Create Particle Classes
    - Write definitions + Test methods.
    - Come up with a way to generate neighbor list (Might need to make a list type object)
    - Test that particles work using a simple 3x3 grid or something

 - Write some SPH code
    - Generate particle list, use this to get each particle's neighbor list
    - Implement Algorithm

  - Optimize Serial code

  - Write parallel code

  - Optimize parallel code

TODO / development history:
 - Vector class:
    DONE 6/5: Move class and methods to separate header/source file
    DONE 6/5: Add += operator
    DONE 6/5: Remove the 'vector constructor' ( = overloading is more natural)
    DONE 6/5: Add *=, / (divide vector by scalar), * (scalar multiplication + friend) overloading
    DONE 6/6: Move V member to private section
    DONE 6/6: Improve operator overloading
    DONE 6/6: Add magnitude method
    DONE 6/7: Test all new operators!
    DONE 6/7: Add a destructor
    DONE 6/7: Add a copy constructor
    DONE 6/7: make applicable methods accept and/or return reference variables
    DONE 6/11: Add Magnitude friend function
    DONE 6/11: Add Dot product friend function
    - Replace printouts with actual errors

 - Tensor Class:
    DONE 6/5: Define (), [], = (to arrays) for tensors.
    DONE 6/5: Move class and methods to a separate header/source file
    DONE 6/5: Add += operator overload.
    DONE 6/6: Add *=, / (divide by scalar), * (scalar multiplication + friend) overloading
    DONE 6/5: Add an inverse function
    DONE 6/6: Move T member to private section
    DONE 6/6: Clean up functions/reorganize
    DONE 6/7: Test all new operators!
    DONE 6/7: Add a destructor
    DONE 6/7: Add a copy constructor
    DONE 6/7: make applicable methods accept and/or return reference variables
    DONE 6/11: Add Transpose, Determinant methods
    DONE 6/11: Add Transpose, Determinant, Inverse friend functions
    DONE 6/11: Add Tensor dot product friend function
    - Replace printouts with actual errors

  - Particle Class:
    - Define all methods
    DONE: Move Grad_W_Tilde into an array of vectors
        - Grad_W is used when calculating A and Grad_W_Tilde. However, I believe
        that both of these only need to be found once. Using the provided
        algorithm, Grad_W_Tilde for each neighbor is calculated for each
        iteration (to calculate the deformation gradient). However, if we look
        at the definition of Grad_W_Tilde, we can see that Grad_W_Tilde for the
        jth neighbor will always be the same (since Grad_W_Tilde is a function
        of just h and Rj (ref position) both of which do not change with time)
        Thus, I believe that it makes sense to store the value of Grad_W_Tilde(Rj,h)
        for each Neighbor in an array of vectors (each particle would get such
        such an array). The idea here is that the jth Vector in the array
        corresponds to Grad_W_Tilde for the jth neighbor! By storing
        Grad_W_tilde for each neighbor in an array, we only need to calculate
        each Grad_W_Tilde once! To calculate F, we simply call the corresponding
        elements of the array. I believe this will greatly enhance performance.
    DONE: Include a static private member 'num neighbors' that keeps track of how
    many neighbors a particles has
      - This number is used to dynamically allocate the Grad_W_Tilde and
      Neighbor_List arrays.

    - Try removing Rj vector from Set_Neighbors method. I think I can just pass
    X_Neighbors[j] - X to Grad_W_Tilde in second loop / avoid an explicit Rj
    vector all together.
    - Remove Force, Acceleration vectors and P, S, F member
        I don't think that these quantities are needed. All of them are eulerian
        These quantities are only used to update the particle's position. Thus,
        these members are not needed to define a particle. Rather, they are
        used to update a particle's position. As such, I think it makes sense
        to treat these quantities as temporary/local variables inside of the
        update_x function. This function would accept the neighbor particle's
        current positions as an argument (as well as the time step) and use this
        to calculate the deformation gradient F.  We then calculate P. We
        then use this to calculate the force, which is used to calculate the
        acceleration. Finally, the acceleration is used to update x (particle's
        spacial position).

        This approach of making these quantities local variables would save a
        boat load of memory since each particle has far fewer members/is smaller.
        With this approach, we only need calculate S, P, F... for the particle
        that is currently being updated).
    - Add Particles array to  main file
    - Have main file set h (static member variable).
    - Come up with an algorithm to generate neighbor list
    - Try initializing particles.

IDEAS:
 - How to implement neighbor list:
     Use a linked list. Create a linked list for each particle. Once a neighbor
     is found, add a node that contains that neighbor's ID and their ref
     position (as a vector) to the list. Keep track of total number of
     neighbors. Once number of neighbors has been discovered, allocate an array
     whose dimension is equal to the number of neighbors. Store the id's in this
     array. Then free the list. Pass the number of neighbors + neighbor id List
     + neighbor ref positions to the particle. The particle uses the number of
     Neighbors to allocate its Neighbor_List and Grad_W_Tilde arrays' (both
     quantities are Lagrangian).

  - How to update each time step:
    The main function has a giant array storing all of the particles. At the
    start of each time step, the program cycles through the particles. For each
    particle, the main function gets the neighbor list from that particle. The
    neighbor list is simply a list of the Array ID's of the neighbors. With
    this information, the main function gathers the position of each particle.
    This is then used to update the current particle's deformation gradient,
    stress tensor, and acceleration. Finally, with the updated acceleration,
    we 'step forward in time' and find the particle's new position.

 - Replace the Vector, Tensor classes with templates (need to look up how to do this)
    - This would allow me to change the data type stored in each tensor depending
    on the application... could be pretty useful (float vs double depending on
    required level of accuracy, etc.)
