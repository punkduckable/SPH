Development Plan:
 - Create Vector, Tensor Classes
     - Write definitions + test all methods... see that they're working

 - Create Particle Classes
    - Write definitions + Test methods.
    - Come up with a way to generate neighbor list (Might need to make a list type object)
    - Test that particles work using a simple 3x3 grid or something

 - Write some SPH code
    - Generate particle list, use this to get each particle's neighbor list
    - Implement Algorithm

  - Optimize Serial code

  - Write parallel code

  - Optimize parallel code

TODO / development history:
 - Vector class:
    DONE 6/5: Move class and methods to separate header/source file
    DONE 6/5: Add += operator
    DONE 6/5: Remove the 'vector constructor' ( = overloading is more natural)
    DONE 6/5: Add *=, / (divide vector by scalar), * (scalar multiplication + friend) overloading
    DONE 6/6: Move V member to private section
    DONE 6/6: Improve operator overloading
    DONE 6/6: Add magnitude method
    DONE 6/7: Test all new operators!
    DONE 6/7: Add a destructor
    DONE 6/7: Add a copy constructor
    DONE 6/7: make applicable methods accept and/or return reference variables
    DONE 6/11: Add Magnitude friend function
    DONE 6/11: Add Dot product friend function
    DONE 6/11: Add print friend function
    - Figure out how to allow access to friend functions (mag, print) outside of class scope

 - Tensor Class:
    DONE 6/5: Define (), [], = (to arrays) for tensors.
    DONE 6/5: Move class and methods to a separate header/source file
    DONE 6/5: Add += operator overload.
    DONE 6/6: Add *=, / (divide by scalar), * (scalar multiplication + friend) overloading
    DONE 6/5: Add an inverse function
    DONE 6/6: Move T member to private section
    DONE 6/6: Clean up functions/reorganize
    DONE 6/7: Test all new operators!
    DONE 6/7: Add a destructor
    DONE 6/7: Add a copy constructor
    DONE 6/7: make applicable methods accept and/or return reference variables
    DONE 6/11: Add Transpose, Determinant methods
    DONE 6/11: Add Transpose, Determinant, Inverse friend functions
    DONE 6/11: Add Tensor dot product friend function
    DONE 6/11: Add print friend function
    - Figure out how to allow access to friend functions (Print, transpose, etc..) outside of class scope

  - Particle Class:
    DONE 6/11: Define all methods
    DONE 6/8: Move Grad_W_Tilde into an array of vectors
        Grad_W is used when calculating A and Grad_W_Tilde. However, I believe
        that both of these only need to be found once. Using the provided
        algorithm, Grad_W_Tilde for each neighbor is calculated for each
        iteration (to calculate the deformation gradient). However, if we look
        at the definition of Grad_W_Tilde, we can see that Grad_W_Tilde for the
        jth neighbor will always be the same (since Grad_W_Tilde is a function
        of just h and Rj (ref position) both of which do not change with time)
        Thus, I believe that it makes sense to store the value of Grad_W_Tilde(Rj,h)
        for each Neighbor in an array of vectors (each particle would get such
        such an array). The idea here is that the jth Vector in the array
        corresponds to Grad_W_Tilde for the jth neighbor! By storing
        Grad_W_tilde for each neighbor in an array, we only need to calculate
        each Grad_W_Tilde once! To calculate F, we simply call the corresponding
        elements of the array. I believe this will greatly enhance performance.
    DONE 6/8: Include a static private member 'num neighbors' that keeps track of how
    many neighbors a particles has
        This number is used to dynamically allocate the Grad_W_Tilde and
        Neighbor_List arrays.
    DONE 6/12: Add in A when calculating W, Grad_W! (see eq (2)).
    DONE 6/12: Update position using acceleration (finish Update_Particle_Position function)
    DONE 6/13: Write a particle test!
    DONE 6/13: Come up with an algorithm to generate neighbor list
    DONE 6/13: Try setting up particles.
    DONE 6/13: add print method
    - implement neighbor list generating function
    - Set density, calculate mass
    - Update penalty function (use eq 6.138 in H book)
    - Find way to set all static member variables in main function

  - Linked List class
    DONE 6/12: Write a two way linked list (will be used for neighbor search)
    DONE 6/12: Add tests for list class

IDEAS:
 - How to implement neighbor list:
     Use a linked list. Create a linked list for each particle. Once a neighbor
     is found, add a node that contains that neighbor's ID and their ref
     position (as a vector) to the list. Keep track of total number of
     neighbors. Once number of neighbors has been discovered, allocate an array
     whose dimension is equal to the number of neighbors. Store the id's in this
     array. Then free the list. Pass the number of neighbors + neighbor id List
     + neighbor ref positions to the particle. The particle uses the number of
     Neighbors to allocate its Neighbor_List and Grad_W_Tilde arrays' (both
     quantities are Lagrangian).

  - How to update each time step:
    The main function has a giant array storing all of the particles. At the
    start of each time step, the program cycles through the particles. For each
    particle, the main function gets the neighbor list from that particle. The
    neighbor list is simply a list of the Array ID's of the neighbors. With
    this information, the main function gathers the position of each particle.
    This is then used to update the current particle's deformation gradient,
    stress tensor, and acceleration. Finally, with the updated acceleration,
    we 'step forward in time' and find the particle's new position.

 - Replace the Vector, Tensor classes with templates (need to look up how to do this)
    - This would allow me to change the data type stored in each tensor depending
    on the application... could be pretty useful (float vs double depending on
    required level of accuracy, etc.)
